<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于TextRank自动摘要]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%9F%BA%E4%BA%8ETextRank%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[摘要：本文主要讲解了TextRank算法和基于TextRank进行文本自动摘要提取 TextRank算法经典的TextRank算法是在 Google公司PageRank算法的启发下，利用投票的原理让每一个节点为它的邻居节点投赞成票，票的权重取决于节点本身的票数 。这是一个“先有蛋还是先有鸡”的悖论。TextRank算法借鉴了PageRank的做法，采用矩阵迭代收敛的方式解决了这个悖论。 TextRank网络图 G=(V,E,W) V : 节点集合。 V={V1,V2, … , Vn} 是由n个元素 Vi (1&lt;=i&lt;=n) 所构成的集合。 E: 边的集合。以 V 中各个 Vi 为节点并以节点的相似关系为边 E=｛(Vi, Vj) | Vi,Vj属于V, w_ij != 0｝ 即边的权重不为0 W: 边上权重的集合。w_ij 是节点 V_i 与 V_j 间边的权重值，通过距离相似度计算函数计算得出（如：欧式距离、Jaccard 或余弦函数等） 相似度矩阵：计算边的权值 该相似度矩阵为对称矩阵，对角线上元素的值为1. 迭代计算公式：迭代计算各个节点的权重 WS(V_i) : 节点 V_i 的权重值（称为PR值） d: 阻尼系数，一般设置为0.85 In(V_i) : 指向V_i 的节点集合 Out(V_i) : V_i 所指向的节点集合 |Out(V_j)| : 集合 Out(V_j) 中元素的个数 上式中左边表示 V_i 的权重，右侧的求和表示每个相邻节点对本节点的贡献程度。求和的分子 w_ij 表示 V_i 和 V_j 间的相似程度，分母为一个加权和，WS(V_j) 代表上一次迭代后节点 V_j 的权重值。 由于计算节点的权重时又需要用到节点本身的权重，因此需要进行迭代。假设每个节点的权重值初始化均为 1/|V|, 即 B_0 = (1/|V|, 1/|V|, … , 1/|V|)T ,经过若干次迭代计算后可收敛。 当两次迭代的结果B_i 和 B_i-1 差别非常小并且接近于0时停止迭代计算。一般经过20-30次迭代就可以达到收敛。 文本的 TextRank 网络图构造文本预处理及特种选择给定一段中文文本，将每个句子作为一个窗口进行分词得到该句子的各个特征项。由于这些特征项的维数非常高，存在许多对摘要提取无用的特征，因此 利用停用词表去掉对这些无用的词，并进行敏感词的过滤 根据 Zipf 法则（也称幂集定律）合理的删除大量低频词 来降低特征空间的维数。 为减少冗余度和提高效果，可以采取特征词相关性分析、聚类、同义词和近义词归并等策略。 预处理之后得到特征词向量 利用相似度函数计算句子之间的相似度，并将其作为句子间边的权重。如果不存在相似度，则他们之间没有边。 给段中文文本D，假定包含n个句子， D={P_1, P_2, … , P_n}, 其中P_i按D 中出现的先后顺序进行排序的句子。于是根据上图的预处理流程对D及P_i进行处理可得： D的特征词向量 每句的特征词向量 用TF-IDF权值法作为特征词的评估函数 （考虑文档长度对权值的影响，并弱化瓷瓶差异较大所带来的影响）评估函数为： N 为分词工具中词典所包含的特征词的总数，N_keyj 为 N_keyj 在 N 中出现的次数。 根据计算结果对特征词进行排序，并取前几个特征词就可得到文档对应的关键词列表。 TextRank 网络图给定各个句子的特征向量空间，可以通过各种距离相似度计算函数计算句子相似度。 余弦相似度函数： 句子相似度矩阵： w_ij 表示句子 P_i 和 P_j 间的相似度。对称矩阵，对角线为1. 以D 中各句子 P_i 为节点并以句子间的相似关系为边，并以句子间的相似度为边的权值可构成一个无向的加权 TextRank 的网络图，其中各节点的权重计算： ( 7 ) 设每个节点的权重值初始化均为 1/|D|, 即 B_0 = (1/|D, 1/|D|, … , 1/|D|)T ,经过若干次迭代计算后可收敛。 收敛后的 B_i 包含了各个句子节点的权重值，根据值的大小进行倒排序可得到相应的句子重要性排名。再选择一定数量 N ([1, |D|])的句子，并结合它们在文本中的先后顺序进行组织就可以构成文本的摘要。如： 根据语料库统计分析摘要句子数量与文本句子数量间的比例以确定合适的N值，或者直接简单地取文本句子总数的一定比例作为摘要句子的数量。 基于改进TextRank算法的自动摘要提取改进TextRank算法 句子与标题之间的相似度 计算各句子与标题句子间的相似度，相似度越高，权重越高。 若标题与句子的特征词完全相同，即其相似度为1，则该句子的最终权重再放大2倍，若完全不同，则保持原权重。 各句子中的特征词是否在标题中也同时出现。 若出现则提升其词频的权重，繁殖，保持词频权重不变。 特殊段落中的句子位置 根据段落及段落中旬子的位置进行加权，对首段中越靠前的句子给予越大的权重提升，末段中越靠后的句子给予越小的权重提升。考虑到收敛后的权重矩阵 B 仍 按句子的先后顺序排序，因此可根据句子的位置设置相应 的权重调整向量 关键句子的处理 如果一个句子自成一段 ，那么这个段落往往起着“ 承上启下 ” 或者“ 过渡句” 的作用 。另外 ，文章中可能有一些小标题 ，也是自成一段的。这些段落一般具有 高概括性 、精炼性的特点，符合摘要本身的要求，故有更大的可能性作为摘 要的一部分 。 特殊句子权重的传递 对首段句子 、末段句子 、关键句子( 统称为特殊句子 ) 进行标记 ，并放大这些 句子传递出去的权重 ，使与之关联的句子获得更大的权值。 句子长度过滤 过长或过短的句子都不应该作为生成摘要的候选句 。 算法实现 根据文档 D构造各个句子的特征词向量 P，并进行句子的长度过滤 。 得到特征词词频矩阵 D_n*h’ 得到标题的向量矩阵 P_0 = [ k_01, … , k_0h’ ]T , 并分别计算各句子与标题的相似度 由式 ( 9 ) 得到 向量 TD_n*1 = [ tws_1, … , tws_n ]T 用以调整最后句子权重 由式( 1 0 ) 调整矩阵 D_n*h 用以调整各句子中的词频的权重 根据式 ( 7 ) 及 矩阵 D_n h 计算各句子间的相似度 ， 并得到相似度矩阵SD_nn 根据 SD_n*n 构建基本的 TextRank 网络图 G 特殊段落的处理和特殊句子权重的传递 ，更新相似度矩阵 SD_n*n 更新图 G，并得到新的 TextRank图 G‘ ， 在 G‘ 上运行 iTextRank 算法获得节点的收敛值矩阵 B_i 由式 ( 11 ) 得到转移矩阵 FP_n*1 依次根据 TD_n1 和 FP_n 1 调整矩阵 B_i 输出句子重要度排序结果 P ， 并 根据句子的先后顺序生成最终的摘要 D]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MLE、MAP和贝叶斯估计]]></title>
    <url>%2F2018%2F11%2F20%2FMLE%E3%80%81MAP%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%2F</url>
    <content type="text"></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%9F%BA%E4%BA%8EHexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[摘要：搭建个人博客 1. 搭建个人博客1.1 安装 Git : 官网下载地址1.2 安装 Node.js : 官网下载地址1234# 打开cmd,以此执行以下步骤，验证是否安装成功。pathnode -vnpm -v 1.3 安装Hexo 在电脑中新建一个 blog 文件夹存放自己的博客，在文件夹内右键点击 Git Bash 进入命令窗口，执行以下代码： 1npm install -g hexo-cli 初始化 Hexo，得到 hexo 文件夹，用于存放 Hexo 博客所有的文件，包括下面会讲到的主题文件，Git Bash 窗口执行以下代码：（无特别提示，以下代码基本都在 Git Bash 命令窗口执行） 配置Hexo, 进入 hexo 文件夹安装依赖，部署形成的文件，分别执行以下代码： 123cd hexonpm installhexo generate 启动服务器：执行以下代码，可以看到服务器端口号是 4000 1hexo server 打开浏览器，地址栏输入http://localhost:4000/ ，结果如下图，可以看到，初始化的 Hexo 博客搭建成功，可以访问。 2. 将初始化的 Hexo 博客部署到 GitHub Pages 注册一个 Github 帐号，新建一个仓库，仓库名为：compassblog.github.io ，如下图所示：（由于我的仓库已经创建，所以会显示仓库已经存在，并且这个仓库的名称必须严格按照 username.github.io 的格式来命名。username就是GitHub登录名） 进入已经建好的仓库，点击 settings ，找到 GitHub Pages 选项，点击 Choose a theme 选择一个主题，然后点击 select theme 选择主题，如下图所示：（到这一步其实已经可以在地址栏访问自己选择的主题了，选择主题这一步其实可以忽略，但我觉得 GitHub 提供的主题还是蛮酷的，所以就附上这一步吧） 配置 Git 个人信息：在 compassblog 目录打开一个 Git Bash 窗口，输入下面的命令 生成 SSH KEY，其实就是生成一个公钥和密钥，因为 GitHub 需要一个密钥才能与本地相连接。执行以下命令，并连续按 3 次回车生成密钥： SSH KEY 生成之后会默认保存在 C:/Users/电脑名用户名/.ssh 目录中，打开这个目录，打开 id_rsa.pub 文件，复制全部内容，即复制密钥。 打开 GitHub ，依次点击 头像–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key，将复制的密钥粘贴到 key 输入框，最后点击 Add Key ，SSH KEY 配置成功，如下图所示： 修改 hexo 文件夹下的 _config.yml 全局配置文件，修改 deploy 属性代码，将本地 hexo 项目托管到 GitHub 上，如下图所示： 执行下面的命令，安装 hexo-deployer-git 插件，快速把代码托管到 GitHub 上(在hexo文件夹下，Gitbash里执行) 执行下面的代码命令，将 hexo 项目托管到 GitHub 上 123hexo cleanhexo ghexo d 浏览器地址栏输入 https://username.github.io/ 访问，可以看到博客已经部署到 GitHub 上，正常访问，如下图所示： 3.配置博客Next 使用文档 Hexo主题配置 个人博客设置 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 1theme: next 3.1 添加“标签”页面 在 Hexo 目录下，新建一个页面，命名为 tags（Hexo 目录，gitbash下） ： 1$ hexo new page tags 注意：如果有启用 多说 或者 Disqus 评论，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;comments: false 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags 3.2 添加“分类”页面 在 Hexo 目录下，新建一个页面，命名为 categories（Hexo 目录，gitbash下） ： 1$ hexo new page categories 注意：如果有启用 多说 或者 Disqus 评论，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags3.3插入本地图片 3.3 插入本地图片 更改站点配置文件 config.yml 1post_asset_folder: true 在hexo 目录中执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 新建博客，在 post 中会生成一个和博客名相同的文件夹和一个 .md 文件 1hexo new &quot;newblog&quot; 把图片放入文件夹，在 .md 文件中使用 1&#123;% imgurl Github-Pages-Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/newblog/pict.jpg ful-image alt:newblog/pict.jpg %&#125; 3.4 设置阅读全文在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 手动进行截断，这是 Hexo 提供的方式，推荐使用。在文章的 front-matter 中添加 description，并提供文章摘录自动形成摘要，在 主题配置文件 中添加： 默认截取的长度为 150 字符，可以根据需要自行设定 123auto_excerpt: enable: true length: 150 3.5 MathJax只讲一种简单的方法 － 插件。安装 1$ npm install hexo-math --save 在 Hexo 文件夹中执行： 1$ hexo math install 在 config.yml 文件中添加： 1plugins: hexo-math 对于不含特殊符号的公式，可以直接使用 MathJax 的 inline math 表达式. 如果含有特殊符号，则需要人肉 escape，如 \ 之类的特殊符号在 LaTex 表达式中出现频率很高，这样就很麻烦，使用 tag 能够省不少事。 具体用法见 Hexo MathJax插件.MathJax用法总结 4. 在 Hexo 博客发布文章并托管到 GitHub Pages 永远的 Hello Hexo ：在 Git Bash 命令窗口执行下面的命令，新建一篇文章 “Hello Hexo”，到博客目录的 /source/_posts/ 文件夹下可以发现，已经生成了标题为 Hello-Hexo.md 的博客文件，如图所示，我们直接编辑自己的文章即可。 1hexo new &quot;Hello Hexo&quot; 给文章添加分类和标签：直接在所要编辑文章的头部添加如下代码即可 123title: 基于Hexo + Github Pages搭建个人博客date: 2018-11-19 20:51:27tags:[Hexo] 本地启动，浏览器测试预览文章，如图所示： 1hero s 添加阅读全文按钮：在文章的任意位置添加下面命令即可 1&lt;!-- more --&gt; 所要发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令，发布到 GitHub Pages 上 123hexo cleanhexo ghexo d 上传成功后，在浏览器地址栏直接访问自己的域名： 直接访问，即可看到自己编写的文章已经发布到了 GitHub 上。并且每次发布文章到 GitHub 都需要执行下面的流程： 123hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
